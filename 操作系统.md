# 操作系统

## 进程通信

> 进程间变量互不可见，因此需要通过在内核中开辟一块缓冲区，进程1把数据拷贝到缓冲区，进程2从缓冲区读取。（管道、消息队列）
>
> Linux的信息量用来操作系统进程间同步访问共享资源

### 1. 管道

- 通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿
- 单向传输
- 效率低下，引进消息队列

```shell
# 匿名管道
netstat -tulnp | grep 8080 "|"就是一条匿名管道，作用是把前一条命令的输出作为后一条命令的输入。
# 命名管道
mkfifo test 创建名字为test的命名管道
进程1：echo "this is a pipe" > test   // 写数据
此时需要另外一个进程把内容读取出来这条命令才会结束
进程2：cat < test  // 读数据
```

### 2. 消息队列

- a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于**缓存**吧。
- 缺点：如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味**发送消息（拷贝）**这个过程需要花很多时间来读内存。

### 3. 内存共享

- 让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了**内存共享**机制了。
- 共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的**线程安全**问题。如何解决这个问题？这个时候我们的**信号量**就上场了。

### 4、信号量

> 例如信号量的初始值是 1，然后 a 进程来访问**内存1**的时候，我们就把信号量的值设为 0，然后进程b 也要来访问**内存1**的时候，看到信号量的值为 0 就知道已经有进程在访问**内存1**了，这个时候进程 b 就会访问不了**内存1**。所以说，信号量也是进程之间的一种通信方式。

- 信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。

### 5、Socket

- 上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？

- 答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。















































































